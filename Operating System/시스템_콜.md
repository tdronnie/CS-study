# 시스템_콜
시스템을 호출하는 것으로 커널 모드의 기능을 사용자 모드가 가능하게 하는 것이다.
모드를 커널 모드로 전환하는 것.

프로세스가 하드웨어에 직접 접근해 기능을 실행할 수 있게 해준다. 사용자를 하드웨어쪽으로 한단계 수준을 내려주는 것

![image](https://user-images.githubusercontent.com/69182630/235512175-de24bc4d-724e-46fe-8e3d-82488fc86772.png)

cf. 사용자 모드 : 유저 접근 영역을 나누고 프로그램 자원에 침범 못하도록 하는 모드<br>
    커널 모드 : 모든 자원(CPU, 메모리 등)에 접하고 명령할 수 있는 모드

시스템 콜 요청을 다 마치면 리턴값으로 사용자 모드를 받는다. 이렇게 다시 사용자 모드로 전환된다.


### fork
프로세스 생성과 제어를 위한 시스템 콜이다.

한 프로세스에서 프로그램 중 fork()를 실행한다면,
현재 프로세스가 부모가 되고 생성되는 프로세스는 자식이 된다. 자식 프로세스는 자신을 생성한 부모 프로세스와 동일한 복사본을 가진다.

OS는 같은 프로그램 2개가 실행된다고 생각해서 자식 프로세스는 처음부터 실행되는 것이 아닌 부모 프로세스 진행 단계와 동일하게 fork()를 실행해서 리턴받는 타이밍이라고 생각한다.

자식 프로세스는 부모 프로세스의 현재 단계부터 시작해서 fork() 실행하지만 리턴값이 다르다. 부모는 자식의 PID를 받지만 자식은 0을 받는다.

스케줄러는 프로세스 우선순위, CPU 사용시간, 입출력 작업 수행 등 다양한 요소를 고려해서 알고리즘을 결정되기 때문에 어떤 프로세스를 먼저 수행할지 예측할 수 없다.

우리는 프로세스가 각자 독립된 주소 공간을 가지고 실행된다는 것만 알 수 있다.


### wait
자식 프로세스가 종료될 때까지 기다리는 작업이다.

wait()는 자식 프로세스가 끝나기 전까지 리턴을 하지 않음으로써 무조건적으로 자식 프로세스가 먼저 실행완료되도록 한다.

### exec
fork는 자식 프로세스가 부모 프로세스와 동작을 동일하게 실행한다. 이와 다르게 exec는 자식 프로세스에서 부모와 다른 동작을 하고 싶을 때 사용한다.

exec() 실행되면 execvp 함수가 실행된다.

cf. execvp(실행 파일, 전달 인자) -> code segment 영역에 실행 파일의 코드를 읽어와서 덮어씌운다. 현재 프로세스를 다른 프로그램으로 대체하는 시스템콜이다

execvp로 코드를 덮어씌운 이후 힙과 스택 등 다른 메모리 영역이 초기화되고 OS는 그대로 실행한다.
새로운 프로세스를 생성하지 않고 현재 프로그램에서 내가 지정한 새로 실행할 파일이 실행되고 원래 프로그램 이후 부분은 실행되지 않는다.

```C
    char *args[] = {"wc", "-l", "file.txt", NULL};
    execvp("wc", args);
```
"wc -l file.txt" 명령어를 execvp 함수로 실행

cf. wc는 파일의 라인 수, 단어 수를 세는 리눅스 명령어


